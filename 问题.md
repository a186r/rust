- 变量与数据交互的方式 —— move(移动)
- clone(克隆)
- **所有权**
- 所有权和作用域的定义、区别
- 堆栈
- **引用与借用**
    - 在任意给定时间，只能拥有一个可变引用或者任意数量的不可变引用
- 数据竞争
    - 两个或者更多指针同时访问同一数据
    - 至少有一个这样的指针被用来写入数据
    - 不存在同步数据访问的机制
- 不同类型的引用slice
- 为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式。在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。
- 解引用强制多态
- Rust是如何在内存中存储字符串的
- 使用生命周期保证引用有效
- **泛型-单态化**
- **trait**
- **生命周期和悬垂引用、引用有效性**

闭包+缓存Cacher
闭包：
    将闭包作为内联匿名函数来使用。
    不过闭包还有另一个函数所没有的功能：他们可以捕获其环境并访问其被定义的作用域的变量。 ----有点像内部函数，可以使用外部函数的所有变量

    move定义，将环境中的元素拿到闭包中来

调用迭代器适配器 map 和闭包结合 ， collect 消费迭代器并将结果收集到一个数据结构中。
 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作

 filter-collect 链式调用 通过过滤器生成新的vector



 结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能

- 结构体内部私有，实现封装

 对结构体定义各种方法，相当于对象的各种方法

 结构体内部私有，对外pub

 继承分享太多，使用 trait 对象替代继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。

 在结构体上实现trait

 我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。

- trait实现类似继承的效果

状态模式的一个缺点是因为状态实现了状态之间的转换，一些状态会相互联系。 状态A-B，如果中间增加状态C,则A、B都要做修改

语法 https://github.com/paritytech/parity-ethereum/blob/master/ethcore/src/engines/authority_round/mod.rs


parity源码：
// TODO: Seal是做什么用的
// TODO: 关于Step：EmptyStep、SealedEmptyStep、PermissionedStep
// TODO: 结构体 EpochManager
// TODO: AuthorityRoundParams是什么意思


- 变量与数据交互的方式 —— move(移动)
- clone(克隆)
- **所有权**
- 所有权和作用域的定义、区别
- 堆栈
- **引用与借用**
    - 在任意给定时间，只能拥有一个可变引用或者任意数量的不可变引用
- 数据竞争
    - 两个或者更多指针同时访问同一数据
    - 至少有一个这样的指针被用来写入数据
    - 不存在同步数据访问的机制
- 不同类型的引用slice
- 为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式。在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。
- 解引用强制多态
- Rust是如何在内存中存储字符串的
- 使用生命周期保证引用有效
- **泛型-单态化**
- **trait**
- **生命周期和悬垂引用、引用有效性**

闭包+缓存Cacher
闭包：
    将闭包作为内联匿名函数来使用。
    不过闭包还有另一个函数所没有的功能：他们可以捕获其环境并访问其被定义的作用域的变量。 ----有点像内部函数，可以使用外部函数的所有变量

    move定义，将环境中的元素拿到闭包中来

调用迭代器适配器 map 和闭包结合 ， collect 消费迭代器并将结果收集到一个数据结构中。
 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作

 filter-collect 链式调用 通过过滤器生成新的vector



 结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能

- 结构体内部私有，实现封装

 对结构体定义各种方法，相当于对象的各种方法

 结构体内部私有，对外pub

 继承分享太多，使用 trait 对象替代继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。

 在结构体上实现trait

 我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。

- trait实现类似继承的效果

状态模式的一个缺点是因为状态实现了状态之间的转换，一些状态会相互联系。 状态A-B，如果中间增加状态C,则A、B都要做修改

语法 https://github.com/paritytech/parity-ethereum/blob/master/ethcore/src/engines/authority_round/mod.rs


parity源码：
// TODO: Seal是做什么用的
// TODO: 关于Step：EmptyStep、SealedEmptyStep、PermissionedStep
// TODO: 结构体 EpochManager


周末两个目标：
- parity使用了哪些加密算法、国密的接口够不够用、各功能之间的交互调用
- parity共识源码

PoA特点：
- PoA是依靠预设好的授权节点顺序产生block
- 可以由已授权的节点投票加入新的节点
- 可指定出块时间

PoA需要考虑的问题：
达成共识的四个阶段：加入共识-出块-验证和投票-退出共识
所以PoA也应该从这四个阶段去做
- 如何加入共识，加入共识对出块的影响，如何保证节点之间动态同步节点验证人列表
- 出块阶段，如何分配出块的权利
- 验证和投票，如何验证有效性，如何保证确定性，节点之间的时间如何同步
- 退出共识对出块的影响，需要做哪些优化,如何保证节点之间动态同步节点验证人列表
- 在共识阶段，如果A、B、C、D、四个节点，A、B、投票加入E，，此时不成立，因为投票没有超过50%，但是如果A、B、C投票移除D，此时加入E的投票会成立

有两种blockchain同步的方法：
1. 经典方法是从创世块开始挨个执行所有交易。这是经过验证的，但是在以太坊网络中，计算量非常大。
2. 仅下载区块头并验证其有效性，之后可以从网络下载任意的近期状态对最近的区块头进行检查。

显然第二种方法更好，由于PoA方案的块可以仅由可信任的签名者来创建，因此，客户端看到的每个块可以与可信任的验证人列表匹配，要验证该块的有效性，就必须得到该块对应的签名者列表

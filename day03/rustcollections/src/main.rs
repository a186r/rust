// 1.vector允许我们一个挨着一个的存储一系列数量可变的值
// 2.字符串是一个字符的集合
// 3.hash map允许我们将值与一个特定的键相关联，这是一个叫做map的更通用的数据结构的特定实现。

// -------------------------------------------新建vector
// 新建一个空的vector来存储i32类型的值
// let v: Vec<i32> = Vc::new();
// 使用vec!宏会根据我们的值来创建一个新的Vec
// let v = vec![1,2,3];


// ------------------------------------------更新vector
// 对于新建一个vector并向其增加元素，可以使用push方法
// let mut v = Vec::new();

// v.push(5);
// v.push(6);
// v.push(7);
// v.push(8);

// 丢弃vector时也会丢弃其所有元素

// ------------------------------------------读取vector的元素
// let v = vec![1,2,3,4,5];
// // 使用&和[]返回一个引用
// let third: &i32 = &v[2];
// // 2018年09月06日18:45:17
// let third: Option<&i32> = v.get(2);

// ----------------------------------------------无效引用
// 一旦程序获取了一个有效的引用，借用检查器将会执行第四章讲到的所有权和借用规则来确保vector内容和这个引用和任何其他引用保持有效。
// 回忆一下不能再相同作用域中同时存在可变和不可变引用的规则。当我们获取vector的第一个元素的不可变引用
// ，并尝试在vector末尾增加一个元素的时候，是行不通的，以下代码报错
// fn main(){
    
// ---------------------------------------遍历vector中的元素
// fn main(){
//     let v = vec![100,32,57];
//     // 通过for遍历vector
//     for i in &v {
//         println!("{}",i);
//     }
// }
// 也可以遍历可变vector的每一个元素的可变引用以便能改变他们
// fn main(){
//     let mut v = vec![1,2,3,4,7,5];
//     for i in &mut v{
//         // 为了修改可变引用所指向的值，在使用+=运算符之前必须使用解引用运算符*获取i中的值。
//         *i += 50;
//         println!("{}",*i);
//     }
// }

// -----------------------------------------------使用枚举来存储多种类型
// 本章开始我们提到vector只能存储相同类型的值，但是绝对会有需要存储一系列不同类型的值的用例。
// 枚举的成员被定义为相同的枚举类型，所以当需要在vector中存储不通类型值时，我可以定义并使用一个枚举。

fn main(){
    enum SpreadsheetCell{
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("hello")),
        SpreadsheetCell::Float(2.3),
    ]
}

// Rust在编译时就必须准确知道vector中类型的原因在于它需要知道存储每个元素到底需要多少内存。第二个好处是
// 可以准确的知道这个vector中允许什么类型，如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误。
// 使用枚举外加 match 意味着 Rust 能在编译时就保证总是会处理所有可能的情况
